#Sun Feb 10 17:52:44 CET 2013
cmdhistory=["(require \:equations.core)" "(require \\"equations.core\\")" "(require [\\"equations.core\\"])" "(require \:equations.core)" "(require 'equations.core)" "(use 'equations.core?" "(use 'equations.core)" "(require 'clojure.string)" "(require 'core.logic)" ";; Switching to equations.core namespace" "(use 'clojure.core.logic)" ";; Switching to equations.core namespace" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (\=\= q true))\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(ns equations.core  \\n  (\:refer-clojure \:exclude [\=\=])\\n  (\:use [clojure.core.logic]))\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (\=\= q true))\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (\=\= q false))\\n(clojure.core/ns user)" ";; Switching to equations.core namespace" "(run* [q]\\n   (conso q [1 2 3]))" "(run* [q]\\n   (conso q [2 3] [1 2 3]))" "(run* [q]\\n   (conso [1] q [1 2 3]))" "(run* [q]\\n   (conso 1 q [1 2 3]))" "(run* [q]\\n   (conso 1 q [1 2 3])\\n   (conso 1 q [2 3 4]))" "(run* [q]\\n   (conso 1 q [1 2 3])\\n   (conso 2 q [2 3 4]))" "(run* [q]\\n    (conde\\n      [succeed]\\n      [fail]))" "(run* [q]\\n    (conde\\n      [succeed]\\n      [succeed]))" "  (run* [q]\\n    (conde\\n      [succeed]\\n      [succeed]))" "(run* [q]\\n    (conde\\n      [succeed (\=\= q 1)]))" "(run* [q]\\n   (conde\\n     [(\=\= q 1)]\\n     [(\=\= q 2)]))" "(defne moveo [before action after]\\n  ([[\:middle \:onbox \:middle \:hasnot]\\n    \:grasp\\n    [\:middle \:onbox \:middle \:has]])\\n  ([[pos \:onfloor pos has]\\n    \:climb\\n    [pos \:onbox pos has]])\\n  ([[pos1 \:onfloor pos1 has]\\n    \:push\\n    [pos2 \:onfloor pos2 has]])\\n  ([[pos1 \:onfloor box has]\\n    \:walk\\n    [pos2 \:onfloor box has]]))" "(defne cangeto [state out]\\n  ([[_ _ _ \:has] true])\\n  ([_ _] (fresh [action next]\\n           (moveo state action next)\\n           (cangeto next out))))" "(run 1 [q]\\n  (cangeto [\:atdoor \:onfloor \:atwindow \:hasnot] q))" ";; Switching to equations.core namespace" "(clojure.core/ns equations.core)\\n(run 1 [q]\\n  (simpl [\:equal [\:mul \:\:M \:V] [\:mul \:Y \:P]] [\:equal \:M [\:div [\:mul \:Y \:P] q]]))\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simpl [before after] \\n  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:mul r-t l-t2] ]])   \\n  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:sum r-t l-t2] ]]) \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run 1 [q]\\n  (simpl q [\:equal [\:mul \:\:M \:V] [\:mul \:Y \:P]]))\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run * [q]\\n  (simpl q [\:equal [\:mul \:\:M \:V] [\:mul \:Y \:P]]))\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run * [q]\\n  (simpl [\:equal [\:mul \:\:M \:V] [\:mul \:Y \:P]] q))\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after] \\n  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:sum r-t l-t2] ]]) \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run * [q]\\n  (simplo [\:equal [\:mul \:\:M \:V] [\:mul \:Y \:P]] q))\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (simplo [\:equal [\:mul \:\:M \:V] [\:mul \:Y \:P]] q))\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  \\n\\n(let [equation [\:equal [\:mul \:\:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  (simplo equation q))\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:\:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  (simplo equation q)\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:\:M \:V] [\:mul \:Y \:P]]]\\n  (run 1 [q]\\n\\t  (simplo equation q)\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:\:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  (simplo equation q)\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after] \\n\\n  ([[\:equal l-t r-t] \\n    [\:equal r-t l-t]])\\n  \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n;  \\n; ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]]) \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:\:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  (simplo equation q)\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  (simplo equation q)\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [[l-comm [t-comm first-t second-t] \:as lb-t rb-t] [r-comm la-t ra-t]] \\n  (conde\\n    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n    [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n    )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [[l-comm [t-comm first-t second-t] \:as lb-t rb-t] [r-comm la-t ra-t]] \\n  (conde\\n    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n    )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [[l-comm [t-comm first-t second-t] \:as lb-t rb-t] [r-comm la-t ra-t]] \\n  (conde\\n  ;  [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n    )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [[l-comm  lb-t rb-t] [r-comm la-t ra-t]] \\n  (conde\\n    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n    )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [[l-comm [t-comm first-t second-t] \:as lb-t rb-t] [r-comm la-t ra-t]] \\n;  (conde\\n;    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n;    )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t] \:as lb-t rb-t] [r-comm la-t ra-t]] \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t] \:as lb-t rb-t] [r-comm la-t ra-t]] \\n  first-t\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(simplo [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]])\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t] \:as lb-t rb-t]] \\n  first-t\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(simplo [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]])\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [[l-comm [t-comm first-t second-t] \:as lb-t rb-t] [r-comm la-t ra-t]] \\n  (conde\\n    [succeed]\\n;    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n    )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t] \:as lb-t rb-t] [r-comm la-t ra-t]] \\n  (conde\\n    [succeed]\\n;    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n    )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t] \:as lb-t rb-t] [r-comm la-t ra-t]] \\n  (conde\\n    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n    )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t] \:as lb-t rb-t] [r-comm la-t ra-t]] \\n  (conde\\n;    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n    )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t] \:as lb-t rb-t] [r-comm la-t ra-t]] \\n ; (conde\\n;    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n  ;  )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t] \:as lb-t rb-t] [r-comm la-t ra-t]] \\n  rb-t\\n ; (conde\\n;    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n  ;  )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t] \:as lb-t rb-t] [r-comm la-t ra-t]] \\n  lb-t\\n ; (conde\\n;    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n  ;  )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(simplo [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]])\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(simplo [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]] nil)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t \:as lb-t]  rb-t] [r-comm la-t ra-t]] \\n  lb-t\\n ; (conde\\n;    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n  ;  )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(simplo [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]] nil)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t \:as lb-t] rb-t] [r-comm la-t ra-t]] \\n  rb-t\\n ; (conde\\n;    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n  ;  )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(simplo [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]] nil)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t \:as lb-t] rb-t] [r-comm la-t ra-t]] \\n  (conde\\n    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n    )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  (simplo equation q)\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t \:as lb-t] rb-t] [r-comm la-t ra-t]] \\n  (conde\\n    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n    )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  (simplo equation q)\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t \:as lb-t] rb-t] [r-comm la-t ra-t]] \\n\\n    [(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  (simplo equation q)\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [[l-comm [t-comm first-t second-t \:as lb-t] rb-t] [r-comm la-t ra-t]] \\n  (conde\\n    [succeed]\\n    ;[(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n    )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  (simplo equation q)\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplo [a b] \\n  (conde\\n    [succeed]\\n    ;[(\=\= ra-t lb-t) (\=\= rb-t la-t) (\=\= l-comm l-comm)] \\n ;   [(\=\= l-comm \:equal) (\=\= t-comm \:mul) (\=\= first-t la-t) (\=\= ra-t [\:div rb-t second-t])]\\n    \\n;  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n;  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n;  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n;    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n    )\\n \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  (simplo equation q)\\n\\t  )\\n  )\\n(clojure.core/ns user)" "concato" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  ;(simplo equation q)\\n    (resto 1 [1 2])\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  ;(simplo equation q)\\n    (resto q [1 2])\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  ;(simplo equation q)\\n    (resto [1 2 3] q)\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  ;(simplo equation q)\\n        \\n    (fresh [left right body]\\n       (conso \:equal right equation)\\n       (conso left right body)\\n       (\=\= q [left right])\\n       )\\n    \\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  ;(simplo equation q)\\n        \\n    (fresh [left right body]\\n       (conso \:equal body equation)\\n       (\=\= q body)\\n       )\\n    \\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  ;(simplo equation q)\\n        \\n    (fresh [left right body temp1 temp2]\\n       (conso \:equal body equation)\\n       (conso left temp1 body)\\n       (resto body right)\\n       (\=\= q [left right])\\n       )\\n    \\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\nbody\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\nresto\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  ;(simplo equation q)\\n        \\n    (fresh [left right body temp1 temp2]\\n       (conso \:equal body equation)\\n       (conso left temp1 body)\\n       (resto body right)\\n       (\=\= q [left right])\\n       )\\n    \\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  ;(simplo equation q)\\n    (conmuto equation q)\\n    \\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne conmuto [before after]\\n  ([[\:equals lb-t rb-t]\\n    [\:equals rb-t rb-t]\\n    ])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  ;(simplo equation q)\\n    (conmuto equation q)\\n    \\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne conmuto [before after]\\n  ([[\:equal lb-t rb-t]\\n    [\:equal rb-t rb-t]\\n    ])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  ;(simplo equation q)\\n    (conmuto equation q)\\n    \\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne conmuto [before after]\\n  ([[\:equal lb-t rb-t]\\n    [\:equal rb-t lb-t]\\n    ])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  ;(simplo equation q)\\n    (conmuto equation q)\\n    \\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  (conde\\n     [(conmuto equation q)]\\n     )\\n    \\n    \\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after] \\n\\n  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne conmuto [before after]\\n  ([[\:equal lb-t rb-t]\\n    [\:equal rb-t lb-t]\\n    ])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n\\t  (conde\\n     [(conmuto equation q)]\\n     [(simplo equation q)]\\n     )\\n    \\n    \\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n    (fres [conmutada]\\n\\t\\t  (conde\\n\\t      [(conmuto equation conmutada) (simplo conmutada q)]\\n\\t      [(simplo equation q)]\\n\\t      )          \\n      )\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n    (fresh [conmutada]\\n\\t\\t  (conde\\n\\t      [(conmuto equation conmutada) (simplo conmutada q)]\\n\\t      [(simplo equation q)]\\n\\t      )          \\n      )\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne conmuto [before after]\\n  ([[op lb-t rb-t]\\n    [op rb-t lb-t]\\n    ])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(let [equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]]]\\n  (run* [q]\\n    (fresh [conmutada]\\n\\t\\t  (conde\\n\\t      [(conmuto equation conmutada) (simplo conmutada q)]\\n\\t      [(simplo equation q)]\\n\\t      )          \\n      )\\n\\t  )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(fact equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]])\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(fact prueba 'proxy-mappings)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defrel prueba q)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(fact prueba 'proxy-mappings)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(fact prueba [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]])\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defrel equation q)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(fact equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]])\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defrel equation q)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(fact equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]])\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (equation equ)\\n  (fresh [conmutada]\\n\\t  (conde\\n      [(conmuto equ conmutada) (simplo conmutada q)]\\n      [(simplo equ q)]\\n      )          \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conde\\n      [(conmuto equ conmutada) (simplo conmutada q)]\\n      [(simplo equ q)]\\n      )          \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn conmutates [[op lt rt] q]\\n  (conde\\n   [(\=\= q [op lt rt])]\\n   [(\=\= q [op rt lt])]\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n    (conmutates equ q)\\n;\\t  (conde\\n;      [(conmuto equ conmutada) (simplo conmutada q)]\\n;      [(simplo equ q)]\\n;      )          \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne conmuto [before after]\\n  ([[op lb-t rb-t]\\n    [op rb-t lb-t]\\n    ])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conde\\n      [(conmuto equ conmutada) (simplo conmutada q)]\\n      [(simplo equ q)]\\n      )          \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after] \\n  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:div r-t l-t2] ]] (succeed))\\n  \\n  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conde\\n      [(conmuto equ conmutada) (simplo conmutada q)]\\n      [(simplo equ q)]\\n      )          \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne appendo [x y z]\\n  ([() _ y])\\n  ([[?a . ?d] _ [?a . ?r]] (appendo ?d y ?r)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne apendo [x y z]\\n  ([() _ y])\\n  ([[?a . ?d] _ [?a . ?r]] (appendo ?d y ?r)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (cons 1 [2] q)  \\n      ;(\=\= nil r)  \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (conso 1 [2] q)  \\n      ;(\=\= nil r)  \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conde\\n      [(conmuto equ conmutada) (simplo conmutada q)]\\n      [(simplo equ q)]\\n      )          \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne conmuto [before after]\\n  ([[op lb-t rb-t]\\n    [op rb-t lb-t]\\n    ])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conde\\n      [(conmuto equ conmutada) (simplo conmutada q)]\\n      [(simplo equ q)]\\n      )          \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after] \\n  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne conmuto [before after]\\n  ([[op lb-t rb-t]\\n    [op rb-t lb-t]\\n    ])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defrel equation q)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(fact equation [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]])\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conde\\n      [(conmuto equ conmutada) (simplo conmutada q)]\\n      [(simplo equ q)]\\n      )          \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (conso [2] q [2])  \\n      ;(\=\= nil r)  \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (conso [2] q [1 2])  \\n      ;(\=\= nil r)  \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (conso [2] q [2 1])  \\n      ;(\=\= nil r)  \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (appendo [2] q [2 1])  \\n      ;(\=\= nil r)  \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (appendo [2] r [2 1])  \\n      (\=\= nil r)  \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (appendo [2] r [2])  \\n      (\=\= nil r)  \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (appendo r [2] [2])  \\n      (\=\= nil r)  \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (appendo q [2] [2])  \\n      (\=\= nil q)  \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (appendo q [2] [2])  \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (appendo [2] q [2])  \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (appendo [2] q [2]) \\n      (\=\= q '())\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (appendo [2] q [1 2]) \\n      (\=\= q '())\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (appendo [2] r [2]) \\n      (\=\= r '())\\n      (\=\= q true)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (appendo [2] r [1 2]) \\n      (\=\= r '())\\n      (\=\= q true)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (appendo [2] r [2]) \\n      (\=\= r '())\\n      (\=\= q true)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto 2 q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto [2] q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto 2 q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto 2 r)\\n      (\=\= q true)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto [2] r)\\n      (\=\= q true)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto 2 nil)\\n      (\=\= q true)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto 2 r)\\n      (\=\= q r)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto [2] r)\\n      (\=\= q r)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto 2 r)\\n      (\=\= q r)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto '(2) r)\\n      (\=\= q r)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto 2 r)\\n      (\=\= '() q r)\\n      (\=\= q true)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto 2 r)\\n      (\=\= '() r)\\n      (\=\= q true)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto [2] r)\\n      (\=\= '() r)\\n      (\=\= q true)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto [2] r)\\n      (\!\= '() r)\\n      (\=\= q true)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [r]\\n      (resto 2 r)\\n      (\!\= '() r)\\n      (\=\= q true)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (simplifiyo equ q)          \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplifiyo [before after]\\n  (conde\\n    [(conmuto before after)]\\n    [(\=\= before after)]\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn simplifiyo [before after]\\n  (conde\\n    [(conmuto before after)]\\n    [(\=\= before after)]\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (simplifiyo equ q)          \\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (simplifiyo equ q)\\n    (simplo q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (simplifiyo equ conmutada)\\n    (simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne conmuto [before after]\\n  ([[op lb-t rb-t]\\n    [op rb-t lb-t]\\n    ])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn conmutate [before after]\\n  (conde\\n    [(conmuto before after)]\\n    [(\=\= before after)]\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after] \\n  ([[\:equal [\:mul l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:div r-t l-t2] ]])\\n  \\n  ([[\:equal [\:div l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:mul r-t l-t2] ]]) \\n  \\n  ([[\:equal [\:sum l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:dif r-t l-t2] ]]) \\n  \\n  ([[\:equal [\:dif l-t1 l-t2] r-t  ] \\n    [\:equal l-t1 [\:sum r-t l-t2] ]])    \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([_ _] (conmutate before after))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([\:equal l-t r-t  ] (conmutate l-t after))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([[\:equal l-t r-t ] _] (conmutate l-t after))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([[\:equal [com op1 op2 \:as l-t] r-t ] _] (conmutate l-t after))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([[\:equal l-t r-t] _] (conmutate l-t after))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([[\:equal [com op1 op2] r-t] _] \\n    (fresh []\\n\\t    (operator com)\\n      (opposite com2 com)\\n      (\=\= after [\:equal op1 [op2 r-t op1]])\\n\\t    )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defrel operator op)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(operator \:mul)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(operator \:div)\\n(operator \:diff)\\n(operator \:sum)\\n\\n(defrel opposite op1 op2)\\n(operator \:mul \:div)\\n(operator \:div \:mul)\\n(operator \:diff \:sum)\\n(operator \:sum \:diff)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(opposite \:mul \:div)\\n(opposite \:div \:mul)\\n(opposite \:diff \:sum)\\n(opposite \:sum \:diff)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([[\:equal [com op1 op2] r-t] _] \\n    (fresh []\\n\\t    (operator com)\\n      (opposite com2 com)\\n      (\=\= after [\:equal op1 [op2 r-t op1]])\\n\\t    )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([[\:equal [com op1 op2] r-t] _] \\n    (fresh [com2]\\n\\t    (operator com)\\n      (opposite com2 com)\\n      (\=\= after [\:equal op1 [op2 r-t op1]])\\n\\t    )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    ;(simplo conmutada q)\\n    (\=\= conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn conmutate [before after]\\n  (conde\\n    [(conmuto before after)]\\n    [(\=\= before after)]\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne conmuto [before after]\\n  ([[op lb-t rb-t]\\n    [op rb-t lb-t]\\n    ])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    ;(simplo conmutada q)\\n    (\=\= conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    (\=\= conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([[\:equal [com op1 op2] r-t] _] \\n    (fresh [com2]\\n      (println \\"Prueba\\")\\n\\t    (operator com)\\n      (opposite com2 com)\\n      (\=\= after [\:equal op1 [op2 r-t op1]])\\n\\t    )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    (\=\= conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([[\:equal [com op1 op2] r-t] _] \\n    (fresh [com2]\\n\\t    (operator com)\\n      (opposite com2 com)\\n      (\=\= after [\:equal op1 [op2 r-t op1]])\\n\\t    )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    (\=\= conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([[\:equal [com op1 op2] r-t] _] \\n    (fresh [com2]\\n      (opposite com2 com)\\n      (\=\= after [\:equal op1 [com2 r-t op1]])\\n\\t    )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n    (opposite \:mul q)\\n\\t  ;(conmutate equ conmutada)\\n    ;(simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\nfact operator \:mul)\\n(fact operator \:div)\\n(fact operator \:diff)\\n(fact operator \:sum)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(fact operator \:mul)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(fact opposite \:mul \:div)\\n(fact opposite \:div \:mul)\\n(fact opposite \:diff \:sum)\\n(fact opposite \:sum \:diff)\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n    (opposite \:mul q)\\n\\t  ;(conmutate equ conmutada)\\n    ;(simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n    (opposite \:diff q)\\n\\t  ;(conmutate equ conmutada)\\n    ;(simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n    (opposite \:diff q)\\n\\t  (conmutate equ conmutada)\\n    ;(simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([[\:equal [com op1 op2] r-t] _] \\n    (fresh [com2]\\n      (opposite com2 com)\\n      (\=\= after [\:equal op1 [com2 r-t op2]])\\n\\t    )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([[\:equal [com op1 op2] r-t] _] \\n    (fresh [com2]\\n      (opposite com2 com)\\n      (conde\\n        [(\=\= after [\:equal op1 [com2 r-t op1]])]\\n        [(\=\= after [\:equal op2 [com2 r-t op2]])]\\n        )\\n\\t    )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([[\:equal [com op1 op2] r-t] _] \\n    (fresh [com2]\\n      (opposite com2 com)\\n      (conde\\n        [(\=\= after [\:equal op1 [com2 r-t op1]])]\\n        [(\=\= after [\:equal op2 [com2 r-t op1]])]\\n        )\\n\\t    )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([[\:equal [com op1 op2] r-t] _] \\n    (fresh [com2]\\n      (opposite com2 com)\\n      (conde\\n        [(\=\= after [\:equal op1 [com2 r-t op2]])]\\n        [(\=\= after [\:equal op2 [com2 r-t op1]])]\\n        )\\n\\t    )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.example)\\nnull\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne conmuto [before after]\\n  ([[op lb-t rb-t] _] \\n    (conde\\n\\t    [(\=\= after) [op lb-t rb-t]]\\n\\t    [(\=\= after) [op rb-t lb-t]]      \\n      )))\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne conmuto [before after]\\n  ([_ _] \\n    (conde\\n\\t    [(\=\= after) [op lb-t rb-t]]\\n\\t    [(\=\= after) [op rb-t lb-t]]      \\n      )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne conmuto [before after]\\n  ([[op lb-t rb-t] _] \\n    (conde\\n\\t    [(\=\= after [op lb-t rb-t])]\\n\\t    [(\=\= after [op rb-t lb-t])]      \\n      )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defne simplo [before after]\\n  ([[\:equal [com op1 op2] r-t] _] \\n    (fresh [com2]\\n      (opposite com2 com)\\n      (conde\\n        [(\=\= after [\:equal op1 [com2 r-t op2]])]\\n        [(\=\= after [\:equal op2 [com2 r-t op1]])]))))\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmutate equ conmutada)\\n    (simplo conmutada q)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmuto equ conmutada)\\n    (simplo conmutada q)))\\n(clojure.core/ns user)" "(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmuto equ conmutada)\\n    (simplo conmutada q)))" "(defn equationize [equ] \\n  (run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmuto equ conmutada)\\n    (simplo conmutada q)))\\n  )" "(equationize [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]])" "(equationize [\:equal [\:div [\:mul \:M \:V] \:P] [\:mul \:Y]])" "(equationize [\:equal [\:div [\:mul \:Z \:V] \:P] [\:mul \:Y]])" "(defn equationize [equ] \\n  (run* [q]\\n  (fresh [equ conmutada]\\n\\t  (conmuto equ conmutada)\\n    (simplo conmutada q)))\\n  )" "(equationize [\:equal [\:div [\:mul \:M \:V] \:P] [\:mul \:Y]])" "(equationize [\:equal [\:div [\:mul \:M \:V] \:P] \:Y])" "(equationize [\:equal [\:mul \:M \:V] [\:mul \:Y \:P])" "(equationize [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]])" ";; Switching to equations.core namespace" "(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmuto equ conmutada)\\n    (simplo conmutada q)))" "(clojure.core/ns equations.core)\\n(defn equationize [equ] \\n  (run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmuto equ conmutada)\\n    (simplo conmutada q)))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(defn equationize [equ] \\n  (run* [q]\\n  (fresh [equ conmutada]\\n    (equation eq)\\n\\t  (conmuto equ conmutada)\\n    (simplo conmutada q)))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(run* [q]\\n  (fresh [equ conmutada]\\n    (equation equ)\\n\\t  (conmuto equ conmutada)\\n    (simplo conmutada q)))\\n(clojure.core/ns user)" ";; Switching to equations.core namespace" "(clojure.core/ns equations.core)\\n(defn equationize [system]\\n\\t (run* [q]\\n\\t\\t(fresh [equ conmutada]\\n\\t\\t  ;(equation equ)\\n      (\=\= equ system)\\n\\t\\t  (conmuto equ conmutada)\\n\\t\\t  (simplo conmutada q))) \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.core)\\n(equationize [\:equal [\:mul \:M \:V] [\:mul \:Y \:P]])\\n(clojure.core/ns user)" ";; Switching to equations.diferentiate namespace" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n        (\=\= q expression)\\n        \\n        )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 5 \:X] [\:mul [\:pow \:Y 4]]])\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 5 \:X] [\:mul [\:pow \:Y 4]]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.test.diferentiate)\\n(deftest replace-me ;; FIXME\: write\\n  (is false \\"No tests have been written.\\"))\\n(clojure.core/ns user)" ";; Switching to equations.diferentiate namespace" "(clojure.core/ns equations.diferentiate)\\n(defne derivo [expression variable equation]\\n  ([var1 var1 1])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation])\\n        (derivo expression variable equation)\\n        (\=\= q equation)\\n        )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation]\\n        (derivo expression variable equation)\\n        (\=\= q equation)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate \:X \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate \:X \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([var1 var2 1]\\n    (\!\= var1 var2))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate \:X \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate \:X \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([var1 var2 0]\\n    (\!\= var1 var2))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate \:X \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate \:X \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([var1 var2 0] (\!\= var1 var2))\\n  ([[\:sum term1 term2] var1 [\:sum (derivo term1) (derivo term2)]])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate \:X \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum \:X \:X] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([var1 var2 0] (\!\= var1 var2))\\n  ;([[\:sum term1 term2] var1 [\:sum (derivo term1) (derivo term2)]])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum \:X \:X] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([var1 var2 0] (\!\= var1 var2))\\n  ([[\:sum term1 term2] var1 [\:sum (derivo term1 variable) (derivo term2 variable)]])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum \:X \:X] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([var1 var2 0] (\!\= var1 var2))\\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum \:X \:X] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum \:X \:Y] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([var1 var2 0] (\!\= var1 var2) (\=\= true (keyword? variable)))\\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum \:X \:Y] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([var1 var2 0] (\!\= var1 var2) (\=\= true (keyword? expression)))\\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum \:X \:Y] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne derivo [expression variable equation]\\n  ([var1 var1 1])\\n  \\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([var1 var2 0] (\!\= var1 var2) (\=\= true (keyword? expression)))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum \:X \:Y] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([var1 var2 0])\\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum \:X \:Y] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n (\!\= var1 var2)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum \:X \:Y] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([var1 var2 0] (\!\= var1 var2))\\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum \:X \:Y] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([var1 var2 0] (\!\= var1 var2))\\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum \:X \:Y] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([var1 var2 0] (\!\= var1 var2))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum \:X \:Y] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([[\:mul term1 term2] var1 [\:sum [\:mul term1 d2] [\:mul d2 term1]]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([var1 var2 0] (\!\= var1 var2))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([[\:mul term1 term2] var1 [\:sum [\:mul term1 d2] [\:mul d1 term1]]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([var1 var2 0] (\!\= var1 var2))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum \:X \:Y] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 5 \:X] [\:mul 4 \:Y]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([\:sum 0 term1] (simplifico term1))\\n  ([\:mul 0 term1] 0)\\n  ([\:sum term1 0] (simplifico term1))\\n  ([\:mul term1 0] 0)  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] (simplifico term1)])\\n  ([[\:sum term1 0] (simplifico term1)])\\n  ([[\:mul 0 term1] 0])\\n  ([[\:mul term1 0] 0])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        (derivo expression variable equation)\\n        (simplifico equation simplified)\\n        (\=\= q simplified)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 5 \:X] [\:mul 4 \:Y]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        ;(derivo expression variable equation)\\n        (simplifico expression simplified)\\n        (\=\= q simplified)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5])\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        ;(derivo expression variable equation)\\n           (\=\= equation expression)\\n        (simplifico equation simplified)\\n        (\=\= q simplified)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] (simplifico term1 result)])\\n  ([[\:sum term1 0] (simplifico term1 result)])\\n  ([[\:mul 0 term1] 0])\\n  ([[\:mul term1 0] 0])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        (derivo expression variable equation)\\n           ;(\=\= equation expression)\\n        (simplifico equation simplified)\\n        (\=\= q simplified)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        (derivo expression variable equation)\\n           ;(\=\= equation expression)\\n        ;(simplifico equation simplified)\\n        (\=\= q simplified)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] (simplifico term1 result)])\\n;  ([[\:sum term1 0] (simplifico term1 result)])\\n  ([[\:mul 0 term1] 0])\\n;  ([[\:mul term1 0] 0])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        ;(derivo expression variable equation)\\n        (\=\= equation expression)\\n        (simplifico equation simplified)\\n        (\=\= q simplified)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        ;(derivo expression variable equation)\\n        (\=\= expression equation )\\n        (simplifico equation simplified)\\n        (\=\= q simplified)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        ;(derivo expression variable equation)\\n        (\=\= expression equation)\\n        ;(simplifico equation simplified)\\n        (\=\= q simplified)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        ;(derivo expression variable equation)\\n        (\=\= expression equation)\\n        ;(simplifico equation simplified)\\n        (\=\= q equation)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        ;(derivo expression variable equation)\\n        (\=\= expression equation)\\n        (simplifico equation simplified)\\n        (\=\= q simplified)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] (simplifico term1 result)])\\n;  ([[\:sum term1 0] (simplifico term1 result)])\\n  ([[\:mul 0 term1] 0])\\n;  ([[\:mul term1 0] 0])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] 0])\\n;  ([[\:sum term1 0] (simplifico term1 result)])\\n  ([[\:mul 0 term1] 0])\\n;  ([[\:mul term1 0] 0])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplifico term1 result)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] (simplifico term1 result)])\\n;  ([[\:sum term1 0] (simplifico term1 result)])\\n  ([[\:mul 0 term1] 0])\\n;  ([[\:mul term1 0] 0])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n;  ([[\:sum term1 0] (simplifico term1 result)])\\n  ([[\:mul 0 term1] 0])\\n;  ([[\:mul term1 0] 0])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n;  ([[\:sum term1 0] (simplifico term1 result)])\\n  ([[\:mul 0 term1] 0])\\n;  ([[\:mul term1 0] 0])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n;  ([[\:sum term1 0] (simplifico term1 result)])\\n  ([[\:mul 0 term1] 0])\\n  ([term term])\\n;  ([[\:mul term1 0] 0])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n  ([[\:sum term1 0] (simplifico term1 result)])\\n  ([[\:mul 0 term1] 0])\\n  ([term term])\\n  ([[\:mul term1 0] 0])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 0 5] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 5 0] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n  ([[\:sum term1 0] res] (simplifico term1 res))\\n  ([[\:mul 0 term1] 0])\\n  ([[\:mul term1 0] 0])\\n  ([term term])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 5 0] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 5 0] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 5 \:X] [\:mul 4 \:Y]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        (derivo expression variable equation)\\n        (\=\= expression equation)\\n        (simplifico equation simplified)\\n        (\=\= q simplified)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 5 \:X] [\:mul 4 \:Y]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        (derivo expression variable equation)\\n        (\=\= expression equation)\\n        (simplifico equation simplified)\\n        (\=\= q simplified)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 5 \:X] [\:mul 4 \:Y]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        (derivo expression variable equation)\\n        (\=\= expression equation)\\n        ;(simplifico equation simplified)\\n        (\=\= q equation)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 5 \:X] [\:mul 4 \:Y]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna derivo [expression variable equation]\\n  ([var1 var1 1])\\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([[\:mul term1 term2] var1 [\:sum [\:mul term1 d2] [\:mul d1 term1]]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([var1 var2 0] (\!\= var1 var2))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 5 \:X] [\:mul 4 \:Y]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna derivo [expression variable equation] \\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([[\:mul term1 term2] var1 [\:sum [\:mul term1 d2] [\:mul d1 term1]]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([var1 var1 1])\\n  ([var1 var2 0] (\!\= var1 var2))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 5 \:X] [\:mul 4 \:Y]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum 5 [\:mul 2 \:Y]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 2 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        (derivo expression variable equation)\\n        ;(simplifico equation simplified)\\n        (\=\= q equation)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 2 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        (derivo expression variable equation)\\n        (simplifico equation simplified)\\n        (\=\= q equation)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 2 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        (derivo expression variable equation)\\n        (simplifico equation simplified)\\n        (\=\= q simplified)\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 2 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n  ([[\:sum term1 0] res] (simplifico term1 res))\\n  ([[\:mul 0 term1] 0])\\n  ([[\:mul term1 0] 0])\\n  ([[oper term1 term2] [oper simp1 simp2]] (simplifico term1 simp1) (simplifico term2 simp2))\\n  ([term term])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 2 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        (derivo expression variable equation)\\n        (simplifico equation simplified)\\n        (\=\= q [equation simplified])\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 2 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n  ([[\:sum term1 0] res] (simplifico term1 res))\\n  ([[\:mul 0 term1] 0])\\n  ([[\:mul term1 0] 0])\\n  ([[oper term1 term2] simplified-res] \\n    (fres [res1 res2]\\n          (simplifico term1 simp1) \\n          (simplifico term2 simp2)\\n          (\=\= simplified-res [oper simp1 simp2])\\n          ))\\n  ([term term])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n  ([[\:sum term1 0] res] (simplifico term1 res))\\n  ([[\:mul 0 term1] 0])\\n  ([[\:mul term1 0] 0])\\n  ([[oper term1 term2] simplified-res] \\n    (fres [simp1 simp2]\\n          (simplifico term1 simp1) \\n          (simplifico term2 simp2)\\n          (simplifico [oper simp1 simp2] simplified-res)\\n          ))\\n  ([term term])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n  ([[\:sum term1 0] res] (simplifico term1 res))\\n  ([[\:mul 0 term1] 0])\\n  ([[\:mul term1 0] 0])\\n  ([[oper term1 term2] simplified-res] \\n    (fresh [simp1 simp2]\\n          (simplifico term1 simp1) \\n          (simplifico term2 simp2)\\n          (simplifico [oper simp1 simp2] simplified-res)\\n          ))\\n  ([term term])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 2 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n        (derivo expression variable equation)\\n        (simplifico equation simplified)\\n        (\=\= q [equation simplified])\\n        )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 2 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n  ([[\:sum term1 0] res] (simplifico term1 res))\\n  ([[\:mul 0 term1] 0])\\n  ([[\:mul term1 0] 0])\\n  ([[oper term1 term2] simplified-res] \\n    (fresh [simp1 simp2]\\n          (simplifico term1 simp1) \\n          (simplifico term2 simp2)\\n          (simplifico [oper simp1 simp2] simplified-res)\\n          ))\\n  ([term term])  \\n  )\\n(clojure.core/ns user)" ";; Switching to equations.diferentiate namespace" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 2 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna derivo [expression variable equation] \\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([[\:mul term1 term2] var1 [\:sum [\:mul term1 d2] [\:mul d1 term1]]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([var1 var1 1])\\n  ([var1 var2 0] (\!\= var1 var2))\\n  )\\n(clojure.core/ns user)" ";; Switching to equations.core namespace" ";; Switching to equations.diferentiate namespace" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 0 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n  ([[\:sum term1 0] res] (simplifico term1 res))\\n  ([[\:mul 0 term1] 0])\\n  ([[\:mul term1 0] 0])\\n;  ([[oper term1 term2] simplified-res] \\n;    (fresh [simp1 simp2]\\n;          (simplifico term1 simp1) \\n;(simplifico term2 simp2)\\n;          (simplifico [oper simp1 simp2] simplified-res)\\n;          ))\\n  ([term term])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 0 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n  ([[\:sum term1 0] res] (simplifico term1 res))\\n  ([[\:mul 0 term1] 0])\\n  ([[\:mul term1 0] 0])\\n  ([[oper term1 term2] simplified-res] \\n    (fresh [simp1 simp2]\\n          (simplifico term1 simp1) \\n(simplifico term2 simp2)\\n          (simplifico [oper simp1 simp2] simplified-res)\\n          ))\\n  ([term term])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 0 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n      (derivo expression variable equation)\\n      (simplifico equation simplified)\\n      (\=\= q [equation \\"******\\" simplified])\\n      )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 0 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n      (derivo expression variable equation)\\n      (simplifico equation simplified)\\n      (\=\= q [equation \\"//\\" simplified])\\n      )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 0 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 5 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 0 \:Y] \:Y)\\n(clojure.core/ns user)" ";; Switching to equations.diferentiate namespace" "(doc conde)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n  ([[\:sum term1 0] res] (simplifico term1 res))\\n  ([[\:mul 0 term1] 0])\\n  ([[\:mul term1 0] 0])\\n  ([[oper term1 term2] simplified-res] \\n    (fresh [simp1 simp2]\\n          (simplifico term1 simp1) \\n          (simplifico term2 simp2)\\n          ;(simplifico [oper simp1 simp2] simplified-res)\\n          [\:oper simp1 simp2]\\n          ))\\n  ([term term])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n  ([[\:sum term1 0] res] (simplifico term1 res))\\n  ([[\:mul 0 term1] 0])\\n  ([[\:mul term1 0] 0])\\n  ([[oper term1 term2] simplified-res] \\n    (fresh [simp1 simp2]\\n          (simplifico term1 simp1) \\n          (simplifico term2 simp2)\\n          ;(simplifico [oper simp1 simp2] simplified-res)\\n          (\=\= simplified-res [\:oper simp1 simp2])\\n          ))\\n  ([term term])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 0 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n  ([[\:sum term1 0] res] (simplifico term1 res))\\n  ([[\:mul 0 term1] 0])\\n  ([[\:mul term1 0] 0])\\n  ([[oper term1 term2] simplified-res] \\n    (fresh [simp1 simp2]\\n          (simplifico term1 simp1) \\n          (simplifico term2 simp2)\\n          ;(simplifico [oper simp1 simp2] simplified-res)\\n          (\=\= simplified-res [oper simp1 simp2])\\n          ))\\n  ([term term])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 0 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna simplifico [original result]\\n  ([[\:sum 0 term1] res] (simplifico term1 res))\\n  ([[\:sum term1 0] res] (simplifico term1 res))\\n  ([[\:mul 0 term1] 0])\\n  ([[\:mul term1 0] 0])\\n  ([[oper term1 term2] simplified-res] \\n    (fresh [simp1 simp2]\\n          (simplifico term1 simp1) \\n          (simplifico term2 simp2)\\n          (\=\= simplified-res [oper simp1 simp2])\\n          ))\\n  ([term term])  \\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified]\\n      (derivo expression variable equation)\\n      (simplifico equation simplified)\\n      (\=\= q [equation \\"//\\" simplified])\\n      )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 0 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified1 simplified2]\\n      (derivo expression variable equation)\\n      (simplifico equation simplified)\\n      (simplifico simplified simplified2)\\n      (\=\= q [equation \\"//\\" simplified2])\\n      )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified1 simplified2]\\n      (derivo expression variable equation)\\n      (simplifico equation simplified)\\n      (simplifico simplified1 simplified2)\\n      (\=\= q [equation \\"//\\" simplified2])\\n      )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified1 simplified2]\\n      (derivo expression variable equation)\\n      (simplifico equation simplified1)\\n      (simplifico simplified1 simplified2)\\n      (\=\= q [equation \\"//\\" simplified2])\\n      )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:mul 0 \:Y] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified1 simplified2]\\n      (derivo expression variable equation)\\n      (simplifico equation simplified1)\\n      (simplifico simplified1 simplified2)\\n      (\=\= q [equation \\"//\\" simplified1 \\"//\\" simplified2])\\n      )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n    (fresh [equation simplified1 simplified2 simplified3]\\n      (derivo expression variable equation)\\n      (simplifico equation simplified1)\\n      (simplifico simplified1 simplified2)\\n      (simplifico simplified2 simplified3)\\n      (\=\= q [equation \\"//\\" simplified2 \\"//\\" simplified3])\\n      )\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2]\\n     (\=\= x \:X)\\n     (\=\= y [])\\n     (\=\= res1 (keyword? x))\\n     (\=\= res2 (keyword? y))\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2]\\n     (\=\= x \:X)\\n     (\=\= y [])\\n     (\=\= res1 (type x))\\n     (\=\= res2 (keyword? y))\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2]\\n     (\=\= x \:X)\\n     (\=\= y [])\\n     (\=\= res1 (lvar? x))\\n     (\=\= res2 (keyword? y))\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2]\\n     (\=\= x \:X)\\n     (\=\= y [])\\n     (\=\= res1 (lvar? x))\\n     (\=\= res2 (lvar? y))\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [])\\n     (membero temp x)\\n     ()\\n     (\=\= res1 (lvar? x))\\n     (\=\= res2 (lvar? y))\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [])\\n     (membero temp x)\\n     (\=\= res1 (lvar? x))\\n     (\=\= res2 (lvar? y))\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [])\\n     (membero temp y)\\n     (\=\= res1 (lvar? x))\\n     (\=\= res2 (lvar? y))\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [s])\\n     (membero temp y)\\n     (\=\= res1 (lvar? x))\\n     (\=\= res2 (lvar? y))\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [5])\\n     (membero temp y)\\n     (\=\= res1 (lvar? x))\\n     (\=\= res2 (lvar? y))\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [])\\n     (membero temp y)\\n     (\=\= res1 (lvar? x))\\n     (\=\= res2 (lvar? y))\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn collectiono [col result]\\n  (conda\\n    (fresh [temp]\\n      (membero temp col)\\n      (\=\= result true)\\n      )\\n    (\=\= result false)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [])\\n     (membero temp y)\\n     (\=\= res1 (lvar? x))\\n     (\=\= res2 (lvar? y))\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne collectiono [col result]\\n  (conda\\n    (fresh [temp]\\n      (membero temp col)\\n      (\=\= result true)\\n      )\\n    (\=\= result false)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn collectiono [col result]\\n  (conde\\n    (fresh [temp]\\n      (membero temp col)\\n      (\=\= result true)\\n      )\\n    (\=\= result false)\\n    )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(\=\= result false)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn collectiono [col result]\\n  (fresh [tmp]\\n\\t  (conde\\n\\t    (membero tmp col) (\=\= result true)\\n\\t    (\=\= result false)\\n\\t    )\\n    )\\n\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn collectiono [col result]\\n  (fresh [tmp]\\n\\t  (conde\\n\\t    (membero tmp col) (\=\= result true)\\n\\t    (\=\= result false) (\=\= result false)\\n\\t    )\\n    )\\n\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn collectiono [col result]\\n  (fresh [tmp]\\n\\t  (conde\\n\\t    (\=\= result false) (membero tmp col)\\n\\t    (\=\= result false) (\=\= result false)\\n\\t    )\\n    )\\n\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne collectiono [col result]\\n  ([[_ resto] res] (\=\= resto nil) (res false))\\n  ([[_ resto] res] (\!\= resto nil) (res true))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [])\\n     (collectiono x res1)\\n     (collectiono y res2)\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\na\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [])\\n     (collectiono x res1)\\n     (collectiono y res2)\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna collectiono [col result]\\n  ([[_ resto] res] (\=\= resto nil) (res false))\\n  ([[_ resto] res] (\!\= resto nil) (res true))\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [5 4])\\n     (collectiono x res1)\\n     (collectiono y res2)\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna collectiono [col result]\\n  ([input output] (fresh [temp]\\n                     (membero temp input)\\n                     (\=\= true output)\\n                         ))\\n  ([input true])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [5 4])\\n     (collectiono x res1)\\n     (collectiono y res2)\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna collectiono [col result]\\n  ([input output] (fresh [temp]\\n                     (membero temp input)\\n                     (\=\= true output)\\n                         ))\\n  ([input false])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [5 4])\\n     (collectiono x res1)\\n     (collectiono y res2)\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne collectiono [col result]\\n  ([input output] (fresh [temp]\\n                     (membero temp input)\\n                     (\=\= true output)\\n                         ))\\n  ([input false])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [5 4])\\n     (collectiono x res1)\\n     (collectiono y res2)\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defne collectiono [col result]\\n  ([input output] (fresh [temp]\\n                     (membero temp input)\\n                     (\=\= true output)\\n                         ))\\n  ([input false])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [5 4])\\n     (collectiono x res1)\\n     ;(collectiono y res2)\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2 temp]\\n     (\=\= x \:X)\\n     (\=\= y [5 4])\\n     ;(collectiono x res1)\\n     (collectiono y res2)\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2]\\n     (\=\= x \:X)\\n     (\=\= y [5 4])\\n     ;(collectiono x res1)\\n     (collectiono y res2)\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defnu collectiono [col result]\\n  ([input output] (fresh [temp]\\n                     (membero temp input)\\n                     (\=\= true output)\\n                         ))\\n  ([input false])\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2]\\n     (\=\= x \:X)\\n     (\=\= y [5 4])\\n     ;(collectiono x res1)\\n     (collectiono y res2)\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2]\\n     (\=\= x \:X)\\n     (\=\= y [5 4])\\n     (collectiono x res1)\\n     (collectiono y res2)\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2]\\n     (\=\= x \:X)\\n     (\=\= y [5 4 sdf \:X])\\n     (collectiono x res1)\\n     (collectiono y res2)\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2]\\n     (\=\= x \:X)\\n     (\=\= y [5 4 \:sdf \:X])\\n     (collectiono x res1)\\n     (collectiono y res2)\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(run* [q]\\n  (fresh [x y res1 res2]\\n     (\=\= x \:X)\\n     (\=\= y [])\\n     (collectiono x res1)\\n     (collectiono y res2)\\n     (\=\= q [res1 res2])\\n     )\\n  )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n      (derivo expression variable q)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn simplify [expression]\\n   (run* [q]\\n      (simplifico expression variable q)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn simplify [expression]\\n   (run* [q]\\n      (simplifico expression q)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\nnull\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y) ))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)))))\\n(clojure.core/ns user)" ";; Switching to equations.diferentiate namespace" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)\\n(clojure.core/ns user)" "(\=\= [\:mul 0 5] [\:mul 0 5])" "(eq [\:mul 0 5] [\:mul 0 5])" "(\= [\:mul 0 5] [\:mul 0 5])" "(clojure.core/ns equations.diferentiate)\\n(defn simplify [expression]\\n  (loop [simplified (run* [q] (simplifico expression q))]\\n    (if (\= expression simplified))\\n      expression\\n      (recur simplified)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn simplify [expression]\\n  (loop [simplified (run* [q] (simplifico expression q))]\\n    (if (\= expression simplified)\\n      expression\\n      (recur simplified))))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)))\\n(clojure.core/ns user)" ";; Switching to equations.diferentiate namespace" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)))\\n(clojure.core/ns user)" ";; Switching to equations.diferentiate namespace" "(clojure.core/ns equations.diferentiate)\\n(defn simplify [expression]\\n  (let [simplified (first (run* [q] (simplifico expression q)))]\\n    (println simplified)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn simplify [expression]\\n  (let [simplified (first (run* [q] (simplifico expression q)))]\\n    (println expression simplified)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn simplify [expression]\\n  (let [simplified (first (run* [q] (simplifico expression q)))]\\n    (println expression \\"//\\" simplified \\"//\\" (\= expression simplified))))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn simplify [expression]\\n  (let [simplified (first (run* [q] (simplifico expression q)))]\\n    simplified))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (simplify (first (simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)))))))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)))))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify [\:sum [\:sum 0 0] [\:sum [\:mul 5 1] 0]])\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (simplify [\:sum [\:sum 0 0] [\:sum [\:mul 5 1] 0]]) )\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (simplify (simplify [\:sum [\:sum 0 0] [\:sum [\:mul 5 1] 0]]) ))\\n(clojure.core/ns user)" "(\= [\:mul 5 1] [\:mul 5 1])" "(clojure.core/ns equations.diferentiate)\\n(defn simplify [expression]\\n  (loop [simplified (first (run* [q] (simplifico expression q)))]\\n    (if (\= expression simplified)\\n      simplified\\n      (recur simplified))))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)))\\n(clojure.core/ns user)" ";; Switching to equations.diferentiate namespace" "(clojure.core/ns equations.diferentiate)\\n(defn simplify [expression]\\n  (loop [simplified (first (run* [q] (simplifico expression q)))]\\n    (if (\= expression simplified)\\n      simplified\\n      (recur simplified))))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn simplify [expression]\\n  (let [simplified (first (run* [q] (simplifico expression q)))]\\n    simplified))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify [\:sum [\:sum 0 0] [\:sum [\:mul 5 1] 0]])\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn simplify [expression]\\n  (loop [simplified (first (run* [q] (simplifico expression q)))]\\n    (println expression \\"//\\" simplified)\\n    (if (\= expression simplified)\\n      simplified\\n      (recur simplified))))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify [\:sum [\:sum 0 0] [\:sum [\:mul 5 1] 0]])\\n(clojure.core/ns user)" ";; Switching to equations.diferentiate namespace" "(clojure.core/ns equations.diferentiate)\\n(defn simplify [expression]\\n  (loop [original expression \\n         simplified (first (run* [q] (simplifico expression q)))]\\n    \\n    (println simplified \\"//\\" original)\\n    (if (\= simplified original)\\n      simplified\\n      (recur simplified (first (run* [q] (simplifico simplified q)))))))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify [\:sum [\:sum 0 0] [\:sum [\:mul 5 1] 0]])\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:Y)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:X)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn simplify [expression]\\n  (loop [original expression \\n         simplified (first (run* [q] (simplifico expression q)))]\\n    (if (\= simplified original)\\n      simplified\\n      (recur simplified (first (run* [q] (simplifico simplified q)))))))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (differentiate [\:sum [\:mul 9 \:X] [\:mul 5 \:Y]] \:X)))\\n(clojure.core/ns user)" ";; Switching to equations.diferentiate namespace" "(clojure.core/ns equations.diferentiate)\\n(defna derivo [expression variable equation] \\n  ([[\:pow term1 term2] term2 [\:mul term2 [\:pow term1 [\:diff term2 1]]]])\\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([[\:mul term1 term2] var1 [\:sum [\:mul term1 d2] [\:mul d1 term1]]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([var1 var1 1])\\n  ([var1 var2 0] (\!\= var1 var2)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:pow 5 \:X] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna derivo [expression variable equation] \\n  ([[\:pow term1 term2] term2 [\:mul [\:pow term1 [\:diff term2 1]]] term2])\\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([[\:mul term1 term2] var1 [\:sum [\:mul term1 d2] [\:mul d1 term1]]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([var1 var1 1])\\n  ([var1 var2 0] (\!\= var1 var2)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna derivo [expression variable equation] \\n  ([[\:pow term1 term2] term2 [\:mul [\:pow term1 [\:diff term2 1]] term2]])\\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([[\:mul term1 term2] var1 [\:sum [\:mul term1 d2] [\:mul d1 term1]]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([var1 var1 1])\\n  ([var1 var2 0] (\!\= var1 var2)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defn differentiate [expression variable]\\n  (run* [q]\\n      (derivo expression variable q)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:pow 5 \:X] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(defna derivo [expression variable equation] \\n  ([[\:pow term1 term2] term2 [\:mul term1 [\:pow term2 [\:diff term1 1]]]])\\n  ([[\:sum term1 term2] var1 [\:sum d1 d2]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([[\:mul term1 term2] var1 [\:sum [\:mul term1 d2] [\:mul d1 term1]]] (derivo term1 variable d1) (derivo term2 variable d2))\\n  ([var1 var1 1])\\n  ([var1 var2 0] (\!\= var1 var2)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:pow 5 \:X] \:X)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:pow 5 \:X] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(differentiate [\:sum [\:mul 4 [\:pow 2 \:X]] [\:mul 5 \:Y]] \:Y)\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (differentiate [\:sum [\:mul 4 [\:pow 2 \:X]] [\:mul 5 \:Y]] \:Y)))\\n(clojure.core/ns user)" "(clojure.core/ns equations.diferentiate)\\n(simplify (first (differentiate [\:sum [\:mul 4 [\:pow 2 \:X]] [\:mul 5 \:Y]] \:X)))\\n(clojure.core/ns user)"]
eclipse.preferences.version=1
